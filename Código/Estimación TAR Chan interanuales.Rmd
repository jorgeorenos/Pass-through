---
Title: Estimación de los Umbrales
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r cargando librerias, echo=FALSE, include=FALSE}

library(readxl)
library(tidyverse)
library(NTS)
library(knitr)
library(kableExtra)
library(devtools)
```

```{r Cargando datos, echo=FALSE}

datos <- read_excel("D:/Documentos/PES/Para la tesis/Tesis/Pass through/Datos/Datos.xlsx", sheet = "Datos consolidados")

```

# Estimación de los umbrales de inflacón para la estimación del efecto *Pass through*

Para la estimación de los umbrales del modelo TAR se seguirá la metodología propuesta por Chang(1993). Para ello se estima el modelo para cada uno de los umbrales posibles[^1] teniendo como regla de decisión para escoger los umbrales verificar cuales son los modelos que minimizan la suma de residuos al cuadrado. Una vez definido el conjunto de umbrales es posible definir los distintos regímenes de inflación que determinarán el efecto *pass through*.

El modelo a estiamr es:

\[\Delta\%P_t =\beta_0 + \beta_1\Delta\%P_{t-1} + \beta_2e_t + 
\delta_ae_t*(\Delta\%P_{t-1}<\tau) + \beta_3\Delta\%P_{t}^E + \beta_4y_t^{brecha}\]

donde:

$\Delta\%P_t$ Tasa de variación del Índice de Precios al Consumidor

$\beta_0$ Componente autónomo de la tas de inflación

$\Delta\%P_{t-1}$ Componente inercial de la inflación

$e_t$ Tasa de variación del tipo de cambio (tasa de depreciación del tipo de cambio)

$\Delta\%P_{t}^E$ Tasa de variación del Índice de Precios al Consumidor de Estados Unidos

$y_t^{brecha}$ Brecha relativa del producto respecto del potencial

$\tau$ Detona el valor del umbral para el régimen de inflación

$\Delta\%P_{t-1}<\tau$ Variable dicotómica que es 1 en régimen de inflación baja y 0 en régimen de iflación alta

Donde es claro que el uso de la dicotómica separa los regímenes de inflación. 

```{r modelos, include=FALSE}

# Construcción de data frame a utilizar

attach(datos)

datos_modelo <- data.frame(inf_gt_interanual, inf_eua_interanual,
                           var_brecha, deprec_interanual)

#datos_modelo <- datos_modelo

detach(datos)

# construcción de la infalción inercial (inflación del periodo anterior)

inercial <- c(NA, datos_modelo[c(1:256),1])

datos_modelo <- cbind(datos_modelo, inercial)
datos_modelo <- select(.data = datos_modelo, inf_gt_interanual, inercial, 
                       inf_eua_interanual, var_brecha, deprec_interanual)

datos_modelo <- datos_modelo[c(2:257),]

# Reordenando índices
row.names(datos_modelo) <- c(1:256)

```

\begin{center}
Datos a utilizar
\end{center}

```{r Tabla de datos, echo=FALSE}

# con linebrake dentro del agumento col.names podemos separar 
# los nombres según lo especifiquemos

kable(head(datos_modelo), digits = 5,
      col.names = linebreak(c("inflación\nGuatemala", 
                    "inflación inercial\nGuatemala", 
                    "inflación\nEstados Unidos",
                    "brecha del producto", 
                    "Depreciación interanual\nQuetzales x USD 1"), 
                    align = "c"), 
      align = "c", escape = FALSE)

```

## Estimación de los distintos modelos

Como se especificó la varialbe dicotómica $\Delta^{12}P_{t-1}<\tau$ será 1 si el régimen de inflación es bajo o 0 si el régimen de inflación es alto, esto se replica para cad uno de los mosdelos a estimar.

```{r estimación de modelos}
# Creación de todos los posibles umbrales
# Número de umbrales fuera por debajo o arriba de la muestra

umbrales_fuera <- length(inercial) - round(257 - 257*0.3, digits = 0)

# posibles umbrales del modelo

posibles <- sort(inercial)
posibles <- posibles[round((umbrales_fuera/2 + 1), 0):
                       (length(inercial)-round(umbrales_fuera/2,0))] 


# Lista de modelos

nombre_modelos <- c()
modelos <- list()
bases <- list()

# Estimación de los modelos por cada umbral

for (i in c(1:length(posibles))) {
  
  nombre_modelos[i] <- c(sprintf("modelo_%s_%s", i, posibles[i]))
  
  m <- mutate(datos_modelo, 
                     d = ifelse(inercial<posibles[i], yes = 0, no = 1))
  
  bases[[i]] <- m
  
  modelo <- lm(bases[[i]],
                      formula = inf_gt_interanual ~ 1 +
                        deprec_interanual*d + inercial +
                        inf_eua_interanual + var_brecha - d)
  
  modelos[[i]] <- modelo
  
}

names(modelos) <- nombre_modelos
```

Luego de la estimación de los modelos se procede al cálculo de la suma de residuos al cuadrado (ssr) de cada modelo.

```{r calculo SSR}

ssr <- c()

for (i in c(1:length(posibles))) {
  
  ssr[i] <- sum(modelos[[i]]$residuals^2)
  
}
```

## Identificación de los umbrales

Una vez determinada la ssr se procede a la identificacióno de los umbrales escogiendo aquellos que minimicen la ssr.
```{r identificación tau 1}

names(modelos[ssr==min(ssr)])

# eliminamos la primera ssr para poder obtener nuevamente el seungo umbral

ssr2 <- ssr[ssr != min(ssr)]

modelos2 <- modelos[ssr != min(ssr)]

names(modelos2[ssr2 == min(ssr2)])

# Como se observa son los modelos 11 y 12 con inflación de 0.01692999 anual
# los modelo con menor ssr y por lo tanto este es el primer umbral.

# Forma grafica de identificacion del umbral

ggplot() + 
  geom_line(aes(y = ssr, x = posibles), colour = "#3F6E9A", size = 1.3) +
  labs(title = "Estimación de los umbrales", 
       y = "Suma de residuos al cuadrado", x = "Umbrales posibles",
       caption = "Elaboración propia") +
  
  #geom_text(aes(y = min(ssr),
   #             x = posibles[ssr == min(ssr)][1]+ 0.05,
    #            label = "0.14%"), size = 5) +
  #geom_text(aes(y = min(ssr2), 
   #             x = posibles[ssr2 == min(ssr2)]+0.05,
    #            label = "0.44%"), size = 5) +
  
  geom_point(aes(x = posibles[ssr == min(ssr)][1],
                 y = min(ssr)), shape = 1, colour = "red", 
             size = 5, stroke = 1.7) +
  geom_point(aes(x = 0.052,
                 y = 0.00984887), shape = 1, colour = "red", 
             size = 5, stroke = 1.7)+
  
  theme_classic(base_size = 18)
  
```

# Estiamción del modelo con dos umbrales, tres regímenes

Una vez determinado el conjunto de umbrales se procede a la estimación del modelo TAR con tres regímenes inflacionarios.

La nueva especificación es:

\[\Delta\%P_t = \beta_0 + \beta_1\Delta\%P_{t-1} + \beta_2e_t  
+ \delta_ae_t*(\Delta\%P_{t-1}<0.016929)+ 
\delta_be_t*(0.016929\leq\Delta\%P_{t-1}<0.05409)+
\beta_3\Delta\%P_{t}^E+ \beta_4y_t^{brecha}\]

En este caso $(0.016929\leq\Delta^{12}P_{t-1}<0.05409)$ la dicotómica que es 1 si nos encontramos en el regimen de infalción media y es 0 si nos encontramos en el régimen de inflación alta, esto con el fin de establecer el regímen de infalción baja acomo el escenario base.

```{r Estimación del modelo TAR, include = FALSE}

datos_TAR <- datos_modelo %>% 
                mutate(dmen = ifelse(inercial < 0.0345, yes = 1, no = 0),
                       dentre = ifelse(inercial>= 0.0345 & inercial< 0.052,
                                       yes = 1, no = 0))

# Por la forma en la que están construidas las dicotómicas el escenario base
# Es el escenario de infalción baja

attach(datos_TAR)

TAR <- lm(datos_TAR, formula = inf_gt_interanual ~ 1 +
            deprec_interanual*dmen + deprec_interanual*dentre +
            inercial + inf_eua_interanual + var_brecha - dmen - dentre)

detach(datos_TAR)

summary(TAR)

```

\begin{center}
Resultados obtenidos
\end{center}

|Variable                                                   |Coeficiente|Error estándar|
|-----------------------------------------------------------|-----------|--------------|
|$\Delta\%P_{t-1}$                                          |0.31947*** |0.06075       |
|$e_t$                                                      | 0.05689   |0.05023       |
|$\delta_ae_t*(\Delta^\%P_{t-1}<0.016929)$                  |-0.20485 . |0.10993       |
|$\delta_be_t*(0.016929\leq\Delta\%P_{t-1}<0.05409)$        |-0.08009   |0.09415       |
|$\Delta\%P_{t}^{E}$                                        |0.24453*** |0.06552       |

## Comprobación de los supuestos

### Normalidad
```{r Jarque Bera}
tseries::jarque.bera.test(TAR$residuals)
```

```{r Histograma normalidad, echo=FALSE}

ggplot(data.frame(TAR$residuals), aes(x = TAR$residuals)) +
  geom_histogram(aes(y = ..density..), fill = "#3F6E9A", colour = "black") +
  geom_density(size = 1.75) +
  labs(title = "Histograma de los residuos", y = "Densidad", x = "Residuos",
       caption = "Elaboración propia") +
  geom_text(aes(y = 1, x = 1, 
                label = "Jarque-Bera = 8.0461 \np-value =0.0179"), 
            size = 4)+
  theme_classic(base_size = 18) 
```

```{r Gráfico cuantil-cuantil}

ggplot(data.frame(TAR$residuals), aes(sample = TAR$residuals)) +
  stat_qq(distribution = qnorm) + stat_qq_line() +
  labs(title = "Gráfico cuantil-cuantil", y = "observados", x = "Teóricos",
       caption = "Elaboración propia") +
  theme_classic(base_size = 18) 

```


### Autocorrelación
```{r autocorrelacion}
lmtest::bgtest(TAR)
```

### Heterocedasticidad
```{r Heterocedasticidad}
lmtest::bptest(TAR)
```

### Multicolinealidad

```{r VIF}

car::vif(TAR)

```

# Simulaciones de choques cambiarios

```{r Periodo de inflación baja}

inf_baja <- c(0)
lapso <- 10

# Coeficiente del efecto traspaso en regímen de infalción baja

coef_baja <- 0.05689
coef_inercial <- 0.31947
choque <- 1


for (i in c(2:lapso)) {
  
  if(i == 2){
    
    coef_baja[i] <- coef_baja*choque 
  }else{
  
      inf_baja[i] <- inf_baja[i-1]*coef_inercial
  
}}

inf_baja

```




[^1]: Chang(1993) recomienda usar el 70% de las observaciones cenetrales